<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://unpkg.com/streamlit-component-lib@latest/dist/index.js"></script>
    <script>
      (() => {
        if (window.Streamlit) {
          return;
        }

        const RENDER_EVENT = "streamlit:render";

        const inferDataType = (value) => {
          if (value === null || value === undefined) return "json";
          if (Array.isArray(value)) return "json";
          const valueType = typeof value;
          if (valueType === "number") {
            return Number.isInteger(value) ? "int" : "float";
          }
          if (valueType === "boolean") return "bool";
          if (valueType === "string") return "string";
          if (valueType === "bigint") return "int";
          return "json";
        };

        const events = new EventTarget();

        const sendMessage = (type, payload) => {
          const message = {
            isStreamlitMessage: true,
            type,
            ...payload,
          };
          window.parent.postMessage(message, "*");
        };

        window.addEventListener("message", (event) => {
          const data = event.data || {};
          if (!data.isStreamlitMessage) return;
          if (data.type === RENDER_EVENT) {
            events.dispatchEvent(new CustomEvent(RENDER_EVENT, { detail: data }));
          }
        });

        window.Streamlit = {
          setComponentReady: () =>
            sendMessage("streamlit:componentReady", { apiVersion: 1 }),
          setFrameHeight: (height) =>
            sendMessage("streamlit:setFrameHeight", { height }),
          setComponentValue: (value) =>
            sendMessage("streamlit:setComponentValue", {
              value: value ?? null,
              dataType: inferDataType(value),
            }),
          events,
          RENDER_EVENT,
        };
      })();
    </script>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        margin: 0;
        background: transparent;
        font-family: "Source Sans Pro", "Segoe UI", Tahoma, sans-serif;
        color: #0f172a;
      }
      .gmaps-field {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        margin-bottom: 0.75rem;
      }
      .gmaps-label {
        font-weight: 600;
        letter-spacing: 0.06em;
        color: #475569;
        font-size: 0.75rem;
        text-transform: uppercase;
      }
      .gmaps-input {
        position: relative;
        display: flex;
        align-items: center;
        background: #fff;
        border: 1px solid #dfe1e5;
        border-radius: 999px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.12);
        transition: border 0.2s ease, box-shadow 0.2s ease;
        padding: 0.25rem 0.75rem 0.25rem 2.5rem;
      }
      .gmaps-input:focus-within {
        border-color: #4285f4;
        box-shadow: 0 4px 12px rgba(66, 133, 244, 0.25);
      }
      .gmaps-input.is-disabled {
        background: #f1f5f9;
        box-shadow: none;
        border-color: #d1d5db;
      }
      .gmaps-icon {
        position: absolute;
        left: 0.9rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 1.15rem;
        height: 1.15rem;
        color: #ea4335;
      }
      .gmaps-icon svg {
        width: 100%;
        height: 100%;
      }
      .gmaps-input input[type="text"] {
        flex: 1 1 auto;
        min-width: 0;
        background: transparent;
        border: none;
        outline: none;
        font-size: 1rem;
        padding: 0.55rem 0;
        color: inherit;
      }
      .gmaps-input input[type="text"]::placeholder {
        color: #9ca3af;
        font-weight: 400;
      }
      .gmaps-input input[type="text"]:disabled {
        color: #94a3b8;
        cursor: not-allowed;
      }
      .gmaps-clear {
        margin-left: 0.5rem;
        background: transparent;
        border: none;
        border-radius: 999px;
        width: 1.5rem;
        height: 1.5rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: #6b7280;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, opacity 0.15s ease,
          transform 0.15s ease;
        opacity: 0;
        transform: scale(0.85);
        pointer-events: none;
      }
      .gmaps-clear.is-visible {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
      }
      .gmaps-clear:hover,
      .gmaps-clear:focus-visible {
        background: rgba(60, 64, 67, 0.1);
        color: #111827;
      }
      .gmaps-clear:disabled {
        cursor: not-allowed;
        opacity: 0.4;
        pointer-events: none;
        transform: scale(1);
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script>
      const Streamlit = window.Streamlit;
      if (!Streamlit) {
        console.error("Streamlit component lib no disponible en window.Streamlit");
      }

      const sendValue = (payload) => {
        if (Streamlit) {
          Streamlit.setComponentValue(payload);
        }
      };

      const updateHeight = (height) => {
        if (Streamlit) {
          Streamlit.setFrameHeight(height);
        }
      };
      let scriptPromise = null;
      let autocomplete = null;
      let latestArgs = null;
      let inputElement = null;
      let clearButton = null;
      let syncClearButtonVisibility = () => {};

      function ensureScript(apiKey) {
        if (window.google && window.google.maps && window.google.maps.places) {
          return Promise.resolve();
        }
        if (scriptPromise) {
          return scriptPromise;
        }
        scriptPromise = new Promise((resolve, reject) => {
          const existing = document.getElementById("gmaps-sdk");
          if (existing) {
            existing.addEventListener("load", () => resolve());
            existing.addEventListener("error", reject);
            return;
          }
          const script = document.createElement("script");
          script.id = "gmaps-sdk";
          script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places`;
          script.async = true;
          script.defer = true;
          script.onload = () => resolve();
          script.onerror = (err) => reject(err);
          document.head.appendChild(script);
        });
        return scriptPromise;
      }

      function toPayload(place, rawValue) {
        const payload = {
          raw_query: rawValue || "",
        };
        if (place && place.place_id) {
          payload.place_id = place.place_id;
          payload.description =
            place.name || place.formatted_address || rawValue || "";
          if (place.formatted_address) {
            payload.address = place.formatted_address;
          }
          if (place.geometry && place.geometry.location) {
            const loc = place.geometry.location;
            try {
              payload.lat = typeof loc.lat === "function" ? loc.lat() : loc.lat;
            } catch (e) {
              payload.lat = null;
            }
            try {
              payload.lng = typeof loc.lng === "function" ? loc.lng() : loc.lng;
            } catch (e) {
              payload.lng = null;
            }
          }
        } else if (rawValue) {
          payload.description = rawValue;
        }
        return payload;
      }

      function attachAutocomplete() {
        if (!window.google || !window.google.maps || !window.google.maps.places) {
          return;
        }
        if (!inputElement) {
          return;
        }
        if (autocomplete) {
          google.maps.event.clearInstanceListeners(autocomplete);
        }
        const options = {
          fields: ["place_id", "name", "formatted_address", "geometry"],
        };
        if (latestArgs && latestArgs.countryRestriction) {
          options.componentRestrictions = { country: latestArgs.countryRestriction };
        }
        autocomplete = new google.maps.places.Autocomplete(inputElement, options);
        autocomplete.addListener("place_changed", () => {
          const place = autocomplete.getPlace();
          const payload = toPayload(place, inputElement.value);
          sendValue(payload);
          syncClearButtonVisibility();
        });
      }

      function render(event) {
        latestArgs = event.detail.args || {};
        const root = document.getElementById("root");
        const label = latestArgs.label || "";
        const placeholder = latestArgs.placeholder || "";
        const disabled = Boolean(latestArgs.disabled);
        const disabledAttr = disabled ? "disabled" : "";
        const value =
          latestArgs.value ||
          (latestArgs.stored && latestArgs.stored.description) ||
          "";
        const elementId = latestArgs.elementId || "gmaps-autocomplete-input";
        const clearId = `${elementId}__clear`;

        root.innerHTML = `
          <div class="gmaps-field">
            ${label ? `<label class="gmaps-label" for="${elementId}">${label}</label>` : ""}
            <div class="gmaps-input${disabled ? " is-disabled" : ""}">
              <span class="gmaps-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" focusable="false" role="presentation">
                  <path fill="currentColor" d="M12 2a7 7 0 0 0-7 7c0 4.77 6.07 12.39 6.33 12.7a1 1 0 0 0 1.34 0C12.93 21.39 19 13.77 19 9a7 7 0 0 0-7-7Zm0 10a3 3 0 1 1 0-6 3 3 0 0 1 0 6Z" />
                </svg>
              </span>
              <input type="text" id="${elementId}" ${disabledAttr} placeholder="${placeholder}" autocomplete="off" spellcheck="false" />
              <button type="button" class="gmaps-clear" id="${clearId}" ${disabledAttr} aria-label="Limpiar bÃºsqueda">
                <svg viewBox="0 0 24 24" focusable="false" role="presentation">
                  <path fill="currentColor" d="m12 10.586 4.95-4.95 1.414 1.414L13.414 12l4.95 4.95-1.414 1.414L12 13.414l-4.95 4.95-1.414-1.414L10.586 12l-4.95-4.95L7.05 5.636z" />
                </svg>
              </button>
            </div>
          </div>
        `;

        inputElement = document.getElementById(elementId);
        clearButton = document.getElementById(clearId);

        syncClearButtonVisibility = () => {
          if (!clearButton) return;
          if (disabled) {
            clearButton.classList.remove("is-visible");
            return;
          }
          const hasValue = Boolean(inputElement && inputElement.value);
          if (hasValue) {
            clearButton.classList.add("is-visible");
          } else {
            clearButton.classList.remove("is-visible");
          }
        };

        if (inputElement) {
          inputElement.value = value || "";
          inputElement.addEventListener("input", () => {
            const payload = toPayload(null, inputElement.value);
            sendValue(payload);
            syncClearButtonVisibility();
          });
        }

        if (clearButton) {
          clearButton.addEventListener("click", () => {
            if (!inputElement) return;
            inputElement.value = "";
            const payload = toPayload(null, "");
            sendValue(payload);
            inputElement.focus();
            syncClearButtonVisibility();
          });
        }

        syncClearButtonVisibility();

        const updateFrame = () => {
          const height = Math.max(root.offsetHeight + 12, 80);
          updateHeight(height);
        };

        updateFrame();

        if (latestArgs.disabled) {
          sendValue({ raw_query: value || "", description: value || "" });
          return;
        }

        ensureScript(latestArgs.apiKey)
          .then(() => {
            attachAutocomplete();
            syncClearButtonVisibility();
            updateFrame();
          })
          .catch(() => {
            updateFrame();
          });
      }

      if (Streamlit) {
        Streamlit.events.addEventListener(Streamlit.RENDER_EVENT, render);
        Streamlit.setComponentReady();
        Streamlit.setFrameHeight(100);
      }
    </script>
  </body>
</html>
